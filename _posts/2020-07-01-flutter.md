---
layout: post
title:  "Flutter"
date:   2019-12-01 09:00:00
categories: Flutter
---
**Flutter**

&emsp;&emsp;[Flutter](https://flutter.dev/)是新兴的基于Dart语言的跨平台开发框架,本文将记录下日常Flutter开发时,积累的一些使用点滴.

&emsp;&emsp;本文相关工具:

* Flutter: stable channel
* IDE: Android Studio
* Cocoapods
* Gradle

# 1. Flutter的开发模版

&emsp;&emsp;Flutter的开发模版有4种,如下:

```shell
[app]                (default) Generate a Flutter application.
[module]             Generate a project to add a Flutter module to an existing Android or iOS application.
[package]            Generate a shareable Flutter project containing modular Dart code.
[plugin]             Generate a shareable Flutter project containing an API in Dart code with a platform-specific implementation for Android, for iOS code, or for both.
```
&emsp;&emsp;在创建Flutter项目的时候,可以用flutter命令行直接创建或者用Android Studio菜单栏新建项目来创建.

* app:      纯Flutter项目使用,用于直接开发新的Flutter项目
* module:   混合开发项目使用,原理是将代码构建出适合Android与iOS集成的依赖库,集成进已有的Native项目
* package:  Flutter的SDK开发时使用,模块化Flutter的代码
* plugin:   Flutter与Native交互时使用,为双侧添加数据传递的能力

&emsp;&emsp;本文将以module开发模版作为切入点记录混合开发中遇到的日常进行记录,另外会涉及到package与plugin开发模版,至于app开发模版大部分情况下是一致的,差异点会在遇到的时候指出.

# 2. 集成

&emsp;&emsp;[将Flutter集成到现有应用](https://flutter.cn/docs/development/add-to-app)

### 2.1 构建

&emsp;&emsp;将Flutter集成到现有App的方法在社区已经有,方法离不开iOS的Cocoapods和Android的Gradle,原理其实就是Flutter工具可以在module开发模版中生成相应平台的依赖库产物,便于多端集成接入.

&emsp;&emsp;`flutter build`有很多可构建的产物选项,在module中,通常用到的是Android的`aar`和iOS的`ios-framework`,因为这样构建出来的产物可以直接通过Gradle和Cocoapods方式接入到已有App中.

```shell
aar             Build a repository containing an AAR and a POM file.
aot             Build an ahead-of-time compiled snapshot of your app's Dart code.
apk             Build an Android APK file from your app.
appbundle       Build an Android App Bundle file from your app.
bundle          Build the Flutter assets directory from your app.
ios             Build an iOS application bundle (Mac OS X host only).
ios-framework   Produces a .framework directory for a Flutter module and its plugins for integration into existing, plain Xcode projects.
```

&emsp;&emsp;**备注**: 在新版本Flutter中,已经有直接创建Cocoapods依赖库的构建方式了,可以更加方便地进行构建,但原理都是一样的,新的方式只是更傻瓜更方便而已.

&emsp;&emsp;同样的,这些构建也选择不同的参数,如下:

```shell
--[no-]debug         Build a debug version of the current project.
                        (defaults to on)
--[no-]profile       Build a version of the current project specialized for performance profiling.
                        (defaults to on)
--[no-]release       Build a release version of the current project.
                        (defaults to on)
--flavor             Build a custom app flavor as defined by platform-specific build setup.
                        Supports the use of product flavors in Android Gradle scripts, and the use of custom Xcode schemes.
--[no-]pub           Whether to run "flutter pub get" before executing this command.
                        (defaults to on)
--target-platform    The target platform for which the project is compiled.
                        [android-arm (default), android-arm64 (default), android-x86, android-x64 (default)]
--output-dir         The absolute path to the directory where the repository is generated.By default, this is '<current-directory>android/build'.
```

&emsp;&emsp;在不添加额外参数进行构建时,默认会拉取`pub.yaml`内的相关依赖,并把`debug`、`profile`、`release`这三种版本的产物依照顺序构建出来,这是很耗时的操作,在能明确构建的时候,尽量对构建产物作出挑选对提高开发效率能提供极大帮助.

&emsp;&emsp;这里还需要提及一下这三种版本产物的区别:

* debug:    用于debug,可调试、可热更新(JIT,Just In Time,方式编译)、可跟踪性能(但不准),支持模拟器与真机.
* profile:  用于贴近于发布的监控,可跟踪性能,只支持真机
* release:  用于发布,不可调试、不可跟踪性能(AOT, Ahead Of Time,方式编译),只支持真机.

### 2.1 接入

&emsp;&emsp;对于现有的App,接入Flutter是个技术活,虽然Flutter官方已经提供了不少傻瓜式的工具和文档,Flutter也提供了跨端的开发能力,能使得一次开发,多端使用,但是接入姿势如果不对,一次完整开发的时间可能比直接双端原生开发时间还长.

&emsp;&emsp;想要真正达到Flutter跨端开发减少开发时间,提升开发效率这个效果,接入的方式非常讲究.

&emsp;&emsp;对于iOS侧开发来说,毕竟不像Android是亲儿子,在Flutter产物接入到iOS,需要注意的点如下:

* 集成模式
* 集成库安装时间

##### 2.1.1 集成模式

&emsp;&emsp;Flutter的集成模式对应产物的构建版本.

&emsp;&emsp;App发板,使用的是release的构建产物,因为使用的是AOT编译方式,产物经过处理,在iOS端,直接通过Cocoapods集成所有frameworks文件即可,与其他的framework没区别,集成到系统后就是一个framework库,如果原有应用的Cocoapods还不是使用`use_frameworks!`的话,就还需要对podspec文件配置一下支持静态库的集成.这种方式对于不开发Flutter业务的开发者是无感知的,接入Flutter开发前后,都没有什么区别.

&emsp;&emsp;在App开发Flutter相关功能时,使用release的构建产物就不合适了.开发过程中,涉及断点调试,性能监控,数据传递,还想享受Flutter方便的热更新开发,就必须了解一下官方是怎么做的了.

&emsp;&emsp;在创建module开发模版后,会一起创建一个附带`main.dart`文件能单独启动的Example项目,这个项目能让module运行起来查看Flutter测的开发效果.

&emsp;&emsp;在Android Studio做好运行配置后,可以发现,debug模式是可以直接在真机上运行,且支持热更新的,那么它在运行前,到底做了什么?

以module开发模版运行到iOS真机为例:
* 自检Fluter、Xcode等运行环境
* 查找当前目录的pub.yaml及其依赖并构建
* 生成临时的iOS项目.ios/并进行项目配置
* 查找用于安装App到真机的签名证书(可选)
* 使用pod install为临时iOS项目安装依赖(即module开发模版的构建产物)
* 构建临时iOS项目
* 启动电脑端的虚拟机作为调试准备
* 安装到真机上并启动App
* 连接电脑上的虚拟机并进行监听
* 同步电脑上的代码文件到真机中

&emsp;&emsp;一次完整的Flutter运行,Flutter做的事情可不少,同时可以看出为了做到热更新调试代码,Flutter在好几个步骤上做了处理.

&emsp;&emsp;首先,对临时项目进行配置时,Flutter对创建的iOS临时项目模版做了调整,增加了可以执行ruby脚本(位于.ios/Flutter/podhelper.rb)的操作.

```Ruby
flutter_application_path = 'module_path'
load File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb')
#... 中间省略 ...
install_all_flutter_pods(flutter_application_path)
```

&emsp;&emsp;这些操作目的是导入Flutter构建的产物依赖,并且对项目注入用于在电脑端启动VM的脚本`xcode_backend.sh`,当执行`pod install`时,这些操作被执行.

&emsp;&emsp;在iOS临时项目被构建完毕后,Xcode执行打开VM的脚本等待接入,而App在安装到真机时,接入VM监听等待,VM在此时就能对iOS项目实现调试、监控、热更新代码等操作了.

&emsp;&emsp;在了解了原理后,想要在已有项目中也能想用这些功能,也就是复制一下Podfile中的这些集成语句和使用debug构建运行的功夫.此后,在Native侧与Flutter侧开发,都能提高效率了.


##### 2.1.2 集成库安装时间

&emsp;&emsp;Flutter在开发过程中长生的产物体积很大,经常会导致团队中不需要开发Flutter的同学在更新依赖时花很多时间,降低了开发效率.

&emsp;&emsp;为了避免这种情况,在团队中提交Flutter更新依赖需要以release构建的产物为准,产物也尽量以纯产物为合适,构建过程产生的一系列中间产物对不开发Flutter的同学完全无用.剔除后可以省掉接近95%的拉取依赖的时间.

&emsp;&emsp;所以在已有项目中接入Flutter框架开发的时候,为了避免团队的开发效率明升实降,这些规则是不能缺少的.


