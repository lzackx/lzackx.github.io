---
layout: post
title:  "插入排序：算法系列（三）"
date:   2015-12-03 09:00:00
categories: algorithm
---
**插入排序（Insertion Sort）算法步骤**

1. 把一组数据集合分成有序子集和无序子集来看待。
2. 初始时，把数据集合首位数据看成有序子集，把之后的数据看成无序子集。
3. 把有序数据子集后的第一位数据（即无序数据子集的首位）与有序数据子集的末位进行比较，较小的（或较大的，根据比较规则而定）就从有序子集末位数据向首位数据方向移动，重复直至整个数据首位为止。
4. 重复步骤3，将无序子集中的数据逐个插入到有序子集，直至有序子集扩展到与整个数据集合相同（或无序子集内无数据）。

插入排序算法示例代码（Swift语言）：

	func insertionSort(inout array:[Int]){
	    
	    /*
	    **  i:  用于表示无序子集的下标
	    **  j:  用于表示有序子集的下标
	    */
	    var i:Int,j:Int;
	    var exchange:Int;
	    
	    for(i = 1;i < array.count;i++){
	        exchange = array[i];
	        j = i - 1;//j为有序子集的末位，开始插入时，位于无序子集的前一位
	        while((j >= 0) && (array[j] > exchange)){
	            array[j+1] = array[j];
	            j--;
	        }
	    array[j + 1] = exchange;
	    }
	}

	var a:[Int] = [0,2,4,6,8,9,7,5,3,1];      //[0, 2, 4, 6, 8, 9, 7, 5, 3, 1]
	insertionSort(&a);                        //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

冒泡排序算法时间复杂度：

1. 已经按照规则排序好的一组数据

	C(min) = n - 1	    //进行了（n - 1）次的比较(Compare)
	
	M(min) = 0	        //没有进行交换动作(Move)

2. 需要全排序的一组数据

	C(max) = 1 + 2 + 3 + ... + (n - 1) = (n x (n - 1)/2) ＝ O(n^2)
	
	M(max) = C(max) x 3 = O(n^2)

&emsp;&emsp;**总结**:插入排序本质是把一个数据集合分成有序与无序子集来看待，再把有序子集通过无序子集中数据的插入扩展，使整个数据集合成为一个有序集合。
